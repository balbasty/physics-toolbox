function [out,in] = fit(in,opt)
% Loglinear ESTATICS fit.
%
%   The ESTATICS model applies to multi-echo spoiled gradient-echo 
%   acquisitions. It assumes that all echo series possess the same R2* 
%   decay, but different initial signals (at TE=0).
%   This function fits the ESTATICS model using least-squares in the log
%   domain.
%
% FORMAT out = mpm.estatics.loglin.fit(in,opt)
%
% in  - Structure of input data generated by `mpm.io.input`
%
% opt - Structure of parameters with (optional) fields:
%   out.folder ['.']    Output folder 
%   out.fname  ['.nii'] Suffix for output filenames 
%   out.mem    ['map']  Memory map or load output volumes ('map'|'load')
%   fov        [0]      Index of input FOV used for model space (0=bbox)
%   vs         [NaN]    Voxel size of model space
%   coreg      [true]   Initial co-registration
%   subsample  [Inf]    Subsampling distance in mm (Inf=none)
%   threads    [-1]     Number of threads used by SPM (-1=all)
%   verbose    [1]      Verbosity level (0=quiet|1=print|2=plot)
%
% Usually: `NaN` means 'informed default'
%          `Inf` means 'as precise as possible'

% -------------------------------------------------------------------------
% Options
% -------------------------------------------------------------------------
if nargin < 2, opt = struct; end
opt = mpm.estatics.loglin.opt(opt);

% -------------------------------------------------------------------------
% Multithread SPM
% -------------------------------------------------------------------------
nthreads0 = utils.threads.get();
utils.threads.set(opt.threads);

% -------------------------------------------------------------------------
% Index available contrasts (only keep FLASH volumes)
% -------------------------------------------------------------------------
issge       = cellfun(@(x) strcmpi(x.seq, 'SGE'), in);
in          = in(issge);
types       = cellfun(@(x) x.type, in, 'UniformOutput', false);
contrasts   = [unique(types) {'R2s'}];
nbcontrasts = numel(contrasts);

% -------------------------------------------------------------------------
% Co-registration
% -------------------------------------------------------------------------
opt.verbose > 0 && fprintf('Coregister volumes\n');
if opt.coreg
    in = mpm.coregister(in);
end

% -------------------------------------------------------------------------
% Prepare output
% -------------------------------------------------------------------------
opt.verbose > 0 && fprintf('Prepare output data structure\n');
% --- Field of view
dim = zeros(3,0);
mat = zeros(4, 4, 0);
for v=1:numel(in)
    dim(:,end+1)   = in{v}.dim(:)';
    mat(:,:,end+1) = in{v}.mat(:,:);
end
[dim,mat] = utils.fov(dim, mat, opt.vs, opt.fov);
% --- Prefix/Value
prefix = contrasts;
value  = zeros(1,nbcontrasts);
value(end) = 1;
% --- Create
out = mpm.io.output(prefix, dim(:), mat, value, 'single', opt.out);

% -------------------------------------------------------------------------
% Loglinear fit
% -------------------------------------------------------------------------
coreopt = struct('scaled',    opt.scaled, ...
                 'subsample', opt.subsample, ...
                 'verbose',   opt.verbose);
out = mpm.estatics.loglin.fit.core(in,out,coreopt);
   
% -------------------------------------------------------------------------
% Extrapolate signal to TE=0
% -------------------------------------------------------------------------
out = mpm.estatics.extrapolate(out,opt.out.fname);

utils.threads.set(nthreads0);