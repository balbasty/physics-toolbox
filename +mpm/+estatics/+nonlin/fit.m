function [out,in,pred] = fit(in,opt)
% Nonlinear ESTATICS fit.
%
%   The ESTATICS model applies to multi-echo spoiled gradient-echo 
%   acquisitions. It assumes that all echo series possess the same R2* 
%   decay, but different initial signals (at TE=0).
%   This function fits the ESTATICS model using [regularised] non-linear
%   weighted least-squares.
%
% FORMAT out = mpm.estatics.nonlin.fit(in,opt)
%
% in  - Structure of input data generated by `mpm.io.input`
%
% opt - Structure of parameters with (optional) fields:
%   nbscales     [1]       Number of scales (or zoom levels) 
%   nbiter       [20]      Number of iterations per scale
%   tolerance    [1E-4]    Gain threshold for early stopping (per scale)
%   out.folder   ['.']     Output folder 
%   out.fname    ['.nii']  Basis for output filenames 
%   out.mem      ['map']   Memory map or load output volumes (map|load)
%   reg.mode     [0 1]     Regularisation type (0=none|1=l1/tv|2=l2)
%   reg.inter    [5E3]     Regularisation factor (intercepts)
%      .decay    [10]                            (R2* decay)
%   reg.smo      [1E-3]    L1 smoother
%   fov          [0]       Index of input FOV used for model space (0=bbox)
%   vs           [NaN]     Voxel size of model space
%   coreg        [true]    Perform initial co-registration
%   init         ['mean']  Init mode: 'mean'/'logfit'/'minilogfit'
%   subsample    [Inf]     Subsampling distance in mm
%   threads      [-1]      Number of threads used by SPM
%   solver.type      ['cg']    Solver used for L1 regularisation (relax|cg)
%   solver.nbiter    [50]      Number of iterations of the linear solver
%   solver.tolerance [0]       Solver gain threshold for early stopping
%   solver.verbose   [1]       Solver verbosity 
%
% Usually: `NaN` means 'informed default'
%          `Inf` means 'as precise as possible'
% reg.mode and reg.prec take two values: (1) absolute valuefPD,fT1,fMTs
%                                        (2) spatial gradients


% -------------------------------------------------------------------------
% Options
% -------------------------------------------------------------------------
if nargin < 2, opt = struct; end
opt = mpm.estatics.nonlin.opt(opt);

% -------------------------------------------------------------------------
% Multithread SPM
% -------------------------------------------------------------------------
nthreads0 = utils.threads.get();
utils.threads.set(opt.threads);

% -------------------------------------------------------------------------
% Index available contrasts (only keep FLASH volumes)
% -------------------------------------------------------------------------
issge       = cellfun(@(x) strcmpi(x.seq, 'SGE'), in);
in          = in(issge);
types       = cellfun(@(x) x.type, in, 'UniformOutput', false);
contrasts   = [unique(types) {'R2s'}];
nbcontrasts = numel(contrasts);

% -------------------------------------------------------------------------
% Default regularisation parameters
% -------------------------------------------------------------------------
for c=1:numel(contrasts)
    if ~isfield(opt.reg, contrasts{c})
        opt.reg.(contrasts{c}) = opt.reg.inter;
    end
end
lambda = cellfun(@(x) opt.reg.(x), contrasts)';
if opt.verbose > 0, fprintf('Guess mean parameter value to correct regularisation\n'); end
mu = mpm.estatics.loglin.fit.mini(in);
mu = cellfun(@(x) mu.(x).dat, contrasts(:));
lambda0 = lambda;
lambda = lambda ./ mu(:).^2;
if opt.verbose > 0
    for n=1:numel(mu)
        fprintf('* Param %-5s | mean: %7.3g | corrected prec: %7.3g | initial prec: %7.3g\n', ...
                contrasts{n}, mu(n), lambda(n), lambda0(n));
    end
end

% -------------------------------------------------------------------------
% Co-registration
% -------------------------------------------------------------------------
if opt.coreg
    if opt.verbose > 0, fprintf('Coregister volumes\n'); end
    in = mpm.coregister(in);
end

% -------------------------------------------------------------------------
% Prepare output
% -------------------------------------------------------------------------
if opt.verbose > 0, fprintf('Prepare output data structure\n'); end
% --- Field of view
dim = zeros(3,0);
mat = zeros(4, 4, 0);
for v=1:numel(in)
    dim(:,end+1)   = in{v}.dim(:)';
    mat(:,:,end+1) = in{v}.mat(:,:);
end
[dim,mat] = utils.fov(dim, mat, opt.vs, opt.fov, opt.mat);
% --- Multiscale settings
scales = mpm.compute_scales(opt.nbscales, dim, mat, opt.subsample);
% --- Prefix/Value
prefix = contrasts;
value  = zeros(1,nbcontrasts);
dim    = repmat([scales(end).dim(:); 1], [1 nbcontrasts]);
mat    = repmat(scales(end).mat, [1 1 nbcontrasts]);
if opt.reg.mode == 1
    prefix = [prefix {'W'}];
    value  = [value 1];
    dim    = [dim [scales(end).dim(:); 1]];
end
% --- Create
out = mpm.io.output(prefix, dim, mat, value, 'single', opt.out);
% --- Save TR/FA
for v=1:numel(in)
    out.(in{v}.type).extras.TR = in{v}.TR;
    out.(in{v}.type).extras.FA = in{v}.FA;
end

% -------------------------------------------------------------------------
% Initialise with loglinear fit
% -------------------------------------------------------------------------
switch lower(opt.init)
    case 'logfit'
        if opt.verbose > 0, fprintf('Initial loglinear fit\n'); end
        out = mpm.estatics.loglinfit.core(in,out,opt.subsample,opt.verbose);
    case 'mean'
        for k=1:numel(contrasts)
            out.(contrasts{k}).dat(:) = mu(k);
        end
    otherwise
        error('Initialisation mode ''%s'' not implemented.', init);
end
if opt.verbose > 1, mpm.estatics.plot.progress(out,[]); end

% -------------------------------------------------------------------------
% Nonlinear fit
% -------------------------------------------------------------------------
if opt.verbose > 0, fprintf('ESTATICS nonlinear fit\n'); end
ll  = [];
scl = [];
lambda0 = lambda;
for s=numel(scales):-1:1
    
    % ---------------------------------------------------------------------
    % Get scale specific parameters
    % ---------------------------------------------------------------------
    if opt.verbose > 0, fprintf('Scale %i\n', s); end
    dim = scales(s).dim;
    vs  = sqrt(sum(scales(s).mat(1:3,1:3).^2));
    sub = scales(s).sub;
    ff  = scales(s).ff;
    lambda = ff * lambda0 * prod(vs);
    
    it0 = numel(ll)+1;
    for it=1:(opt.nbiter+s-1)
    
        if opt.verbose > 0, fprintf('Iteration %i\n', it); end

        % -----------------------------------------------------------------
        % Update maps
        % -----------------------------------------------------------------
        [ind,K] = utils.symIndices(nbcontrasts);   % Sparse indices for symmetric matrices
        g   = zeros([dim nbcontrasts], 'single');  % Gradient
        H   = zeros([dim K], 'single');            % Hessian (symmetric 4x4 matrix)
        llx = 0;                                   % Log-likelihood: data term
        lly = 0;                                   % Log-likelihood: prior term

        % -----------------------------------------------------------------
        % Loop over volumes
        if opt.verbose > 0, fprintf('Gradient: data '); end
        for v=1:numel(in)
            if opt.verbose > 0, fprintf('%d',v); end

            % - Compute gradient
            subopt = struct('subsample', sub, 'verbose', opt.verbose);
            [llx1,g1,H1] = mpm.estatics.nonlin.gradient(in{v}, out, subopt);
            llx = llx + llx1;

            % - Get index
            k = find(strcmpi(in{v}.type, contrasts));   % Intercept
            l = find(strcmpi('R2s', contrasts));        % Decay
            
            % - Add to full gradient
            gind = [k l];
            g(:,:,:,gind) = g(:,:,:,gind) + g1;
            clear g1
            Hind = [ind(k,k) ind(l,l) ind(k,l)];
            H(:,:,:,Hind) = H(:,:,:,Hind) + H1;
            clear H1
            
            if opt.verbose > 0, fprintf(' '); end
        end
        if opt.verbose > 0, fprintf('\n'); end

        % -----------------------------------------------------------------
        % Gradient: Membrane
        if opt.reg.mode > 0
            if opt.verbose > 0, fprintf('Gradient: membrane '); end
            w    = 0;
            wnew = 0;
            if opt.reg.mode == 1, w = 1./single(out.W.dat()); end
            for k=1:nbcontrasts
                switch opt.reg.mode
                    case 1
                        if opt.verbose > 0, fprintf('.'); end
                        Ly = single(out.(contrasts{k}).dat());
                        [Ly,Dy] = mpm.l1.vel2mom(Ly, lambda(k), vs, w);
                        Dy = sum(sum(Dy.^2,5),4);
                        wnew = wnew + Dy;
                        g(:,:,:,k) = g(:,:,:,k) + Ly;
                        clear Ly
                    case 2
                        if opt.verbose > 0, fprintf('.'); end
                        y  = single(out.(contrasts{k}).dat());
                        Ly = mpm.l2.vel2mom(y, lambda(k), vs);
                        g(:,:,:,k) = g(:,:,:,k) + Ly;
                        lly = lly - 0.5*sum(y(:).*Ly(:), 'double');
                        clear y Ly
                end
            end
            if opt.verbose > 0, fprintf('\n'); end
            if opt.reg.mode == 1
                wnew = sqrt(wnew + opt.reg.smo);
                lly = lly - sum(wnew(:), 'double');
            end
        end

        % -----------------------------------------------------------------
        % Update MTV weights
        if opt.reg.mode ==1
            if opt.verbose > 0, fprintf('Update: MTV weights\n'); end
            out.W.dat(:,:,:) = wnew; clear Wnew
        end

        % -----------------------------------------------------------------
        % Log-likelihood
        ll  = [ll llx+lly];
        scl = [scl s];

        % -----------------------------------------------------------------
        % Load diagonal of the Hessian
        H(:,:,:,1:nbcontrasts) = bsxfun(@plus, H(:,:,:,1:nbcontrasts), sum(H(:,:,:,1:nbcontrasts)) * eps('single'));

        % -----------------------------------------------------------------
        % Gauss-Newton
        % - Compute step
        if opt.reg.mode == 0
        % No regularisation
            dy = mpm.l0.solve(H,g);
        elseif opt.reg.mode == 1
        % Some L1 regularisation
            dy = opt.solver.fun(H, g, w, opt.reg.mode, lambda, vs, opt.solver);
        else
        % Some L2 but no L1 regularisation
            dy = mpm.l2.solve(H, g, opt.reg.mode, lambda, vs);
        end
        clear H g W
        % - Update
        if opt.verbose > 0, fprintf('Update: maps\n'); end
        for k=1:nbcontrasts
            ct = contrasts{k};
            switch ct
                case 'R2s'
                    out.(ct).dat(:,:,:) = max(0, out.(ct).dat(:,:,:) - dy(:,:,:,k));
                otherwise
                    out.(ct).dat(:,:,:) = out.(ct).dat(:,:,:) - dy(:,:,:,k);
            end
        end
        clear dy

        % -----------------------------------------------------------------
        % Gain
        if numel(ll) > it0
            gain = abs((ll(end) - ll(end-1)) / (ll(end-1) - min(ll(it0:end))));
        else
            gain = Inf;
        end

        % -----------------------------------------------------------------
        % Plot
        if opt.verbose > 1, mpm.estatics.plot.progress(out,ll,scl); end
        if opt.verbose > 0, fprintf('%s\n', repmat('-',[1 80])); end
        if opt.verbose > 0, fprintf('ll = %7.3g | llx = %7.3g | lly = %7.3g | gain = %7.3g\n', ll(end), llx, lly, gain); end
        if opt.verbose > 0, fprintf('%s\n', repmat('-',[1 80])); end
       
        % -----------------------------------------------------------------
        % Out?
        if gain < opt.tolerance
            break
        end

    end
        
    % ---------------------------------------------------------------------
    % Resize maps
    % ---------------------------------------------------------------------
    if s ~= 1
        out = mpm.resize_output(out, scales(s-1).dim);
        if opt.verbose > 1, mpm.estatics.plot.progress(out,ll,scl); end
    end
    
end

out  = mpm.estatics.extrapolate(out,opt.out.fname);
pred = mpm.estatics.predict(out,in,opt);

utils.threads.set(nthreads0);