function out = fit(in,pre,opt)
% Nonlinear MPM fit.
%
%   The MPM model derives unknown tissue (log(A), log(R1), log(R2*), 
%   logit(MT)) and acquisition (log(B1+), log(B1/-)) parameters from 
%   acquired volumes using their known influence on the signal equation. 
%   Currently, it only  handles multi-echo spoiled gradient-echo 
%   acquisitions. 
%
% FORMAT out = mpm.nonlin.fit(in,opt)
%
% in  - Structure of input data generated by `mpm.io.input`
%
% opt - Structure of parameters with (optional) fields:
%   parameters   ['']      Parameters to estimate
%   nbscales     [5]       Number of scales (or zoom levels) 
%   nbiter       [4]       Number of iterations per scale
%   tolerance    [1E-4]    Gain threshold for early stopping (per scale)
%   out.folder   ['.']     Output folder 
%   out.fname    ['.nii']  Basis for output filenames 
%   out.mem      ['map']   Memory map or load output volumes (map|load)
%   reg.mode     [0 1]     Regularisation type (0=none|1=l1/tv|2=l2)
%   reg.prec.<c> [10 5E3]  Regularisation factor
%   reg.mean.<c> [NaN]     Prior mean
%   fov          [0]       Index of input FOV used for model space (0=bbox)
%   vs           [NaN]     Voxel size of model space
%   coreg        [true]    Initial co-registration
%   init         ['mean']  Init mode: 'mean'/'logfit'/'minilogfit'
%   subsample    [Inf]     Subsampling distance in mm
%   threads      [-1]      Number of threads used by SPM
%   solver.type      ['relax'] Solver used for L1 regularisation (relax|cg)
%   solver.nbiter    [10]      Number of iterations of the linear solver
%   solver.tolerance [0]       Solver gain threshold for early stopping
%   solver.verbose   [1]       Solver verbosity 
%
% Usually: `NaN` means 'informed default'
%          `Inf` means 'as precise as possible'
% reg.mode and reg.prec take two values: (1) absolute value
%                                        (2) spatial gradients


% -------------------------------------------------------------------------
% Options
% -------------------------------------------------------------------------
if nargin < 2, pre = struct; end
if nargin < 3, opt = struct; end
opt = mpm.nonlin.opt(opt);

% -------------------------------------------------------------------------
% Multithread SPM
% -------------------------------------------------------------------------
nthreads0 = utils.threads.get();
utils.threads.set(opt.threads);

% -------------------------------------------------------------------------
% Index available contrasts (only keep FLASH volumes)
% -------------------------------------------------------------------------
issge       = cellfun(@(x) strcmpi(x.seq, 'SGE'), in);
in          = in(issge);
types       = cellfun(@(x) x.type, in, 'UniformOutput', false);
if isempty(opt.parameters)
    opt.parameters = {'A' 'R1' 'R2s'};
    if any(strcmpi('MTw', types))
        opt.parameters = [opt.parameters {'MT'}];
    end
end
nbparameters = numel(opt.parameters);

% -------------------------------------------------------------------------
% Default regularisation parameters
% -------------------------------------------------------------------------
% --- set default parameters
for prm=opt.parameters
    prm = prm{1};
    if~isfield(opt.reg.prec, prm)
        opt.reg.prec.(prm) = opt.reg.prec.default;
    end
    if~isfield(opt.reg.mean, prm)
        opt.reg.mean.(prm) = opt.reg.mean.default;
    end
    if~isfield(opt.reg.mode, prm)
        opt.reg.mode.(prm) = opt.reg.mode.default;
    end
end
% --- convert named parameters to vectors
reg0 = opt.reg;
opt.reg.mode = cell2mat(cellfun(@(x) reg0.mode.(x), opt.parameters(:), 'UniformOutput', false));
opt.reg.prec = cell2mat(cellfun(@(x) reg0.prec.(x), opt.parameters(:), 'UniformOutput', false));
opt.reg.mean = cellfun(@(x) reg0.mean.(x), opt.parameters(:));
% --- estimate mean parameter value
if opt.verbose > 0, fprintf('Guess mean parameter value\n'); end
mu = mpm.estatics.to_mpm_mini(mpm.estatics.loglin.fit.mini(in));
fields = fieldnames(mu);
for k=1:numel(fields)
   switch fields{k}
        case 'MT'
            mu.logMT.dat = log(mu.MT.dat) - log(1-mu.MT.dat);
        case 'A'
            mu.logA.dat = log(mu.A.dat);
        case 'R1'
            mu.logR1.dat = log(mu.R1.dat);
        case 'R2s'
            mu.logR2s.dat = log(mu.R2s.dat);
    end
    
end
mu0 = mu;
mu = cellfun(@(x) mu.(x).dat, opt.parameters(:));
opt.reg.mean(isnan(opt.reg.mean)) = mu(isnan(opt.reg.mean));
for k=1:numel(opt.reg.mean)
    switch (opt.parameters{k})
        case 'logMT'
            expval = 1./(1+exp(-opt.reg.mean(k)));
        otherwise
            expval = exp(opt.reg.mean(k));
    end
    if opt.verbose > 0
        fprintf('* Param %-6s | mean (log): %8.3g | mean (exp): %8.3g | prec (abs): %6.3g | prec (mem): %6.3g\n', ...
                opt.parameters{k}, opt.reg.mean(k), expval, opt.reg.prec(k,1), opt.reg.prec(k,2));
    end
end

% -------------------------------------------------------------------------
% Co-registration
% -------------------------------------------------------------------------
if opt.verbose > 0, fprintf('Coregister volumes\n'); end
if opt.coreg
    [in,pre] = mpm.coregister(in,pre);
end

% -------------------------------------------------------------------------
% Prepare output
% -------------------------------------------------------------------------
if opt.verbose > 0, fprintf('Prepare output data structure\n'); end
% --- Field of view
dim = zeros(3,0);
mat = zeros(4, 4, 0);
for v=1:numel(in)
    dim(:,end+1)   = in{v}.dim(:)';
    mat(:,:,end+1) = in{v}.mat(:,:);
end
[dim,mat] = utils.fov(dim, mat, opt.vs, opt.fov, opt.mat);
% --- Multiscale settings
scales = mpm.compute_scales(opt.nbscales, dim, mat, opt.subsample);
% --- Prefix/Value
prefix = opt.parameters;
value  = zeros(1,nbparameters);
dim    = repmat([scales(end).dim(:); 1], [1 nbparameters]);
mat    = repmat(scales(end).mat, [1 1 nbparameters]);
if any(opt.reg.mode(:,2)==1)
    prefix = [prefix {'W'}];
    value  = [value 1];
    dim    = [dim [scales(end).dim(:); 1]];
    if ischar(opt.reg.uncertainty) && strcmpi(opt.reg.uncertainty, 'bayes')
        prefix = [prefix {'U'}];
        value  = [value 1E-3];
        dim    = [dim [scales(end).dim(:); nbparameters]];
    end
end
% --- Create
out = mpm.io.output(prefix, dim, mat, value, 'single', opt.out);

% -------------------------------------------------------------------------
% Initialise
% -------------------------------------------------------------------------
switch lower(opt.init)
    case 'mean'
        for k=1:numel(opt.parameters)
            out.(opt.parameters{k}).dat(:) = opt.reg.mean(k);
        end
    case 'zero'
        % Nothing to do
    otherwise
        error('Initialisation mode ''%s'' not implemented.', init);
end
if opt.verbose > 1, mpm.nonlin.plot.progress(out,[],[],mu0); end

% -------------------------------------------------------------------------
% Nonlinear fit
% -------------------------------------------------------------------------
if opt.verbose > 0, fprintf('Full nonlinear fit\n'); end
ll  = [];
scl = [];
opt.reg.prec0 = opt.reg.prec;
for s=numel(scales):-1:1
    
    % ---------------------------------------------------------------------
    % Get scale specific parameters
    % ---------------------------------------------------------------------
    if opt.verbose > 0, fprintf('Scale %i\n', s); end
    dim = scales(s).dim;
    vs  = sqrt(sum(scales(s).mat(1:3,1:3).^2));
    vol = prod(vs);
    sub = scales(s).sub;
    % opt.reg.prec = opt.reg.prec0 * vol;
    
    it0 = numel(ll)+1;
    for it=1:(opt.nbiter+s-1)
    
        if opt.verbose > 0, fprintf('Iteration %i\n', it); end

        % -----------------------------------------------------------------
        % Update maps
        % -----------------------------------------------------------------
        K   = nbparameters;               % Nb gradient elements
        K2  = K*(K+1)/2;                  % Nb Hessian elements
        g   = zeros([dim K],  'single');  % Gradient
        H   = zeros([dim K2], 'single');  % Hessian (symmetric 4x4 matrix)
        llx = 0;                          % Log-likelihood: data term
        lly = 0;                          % Log-likelihood: prior term

        % -----------------------------------------------------------------
        % Gradient: Data term
        if opt.verbose > 0, fprintf('Gradient: data '); end
        for v=1:numel(in)
            if opt.verbose > 0, fprintf('%d',v); end

            subopt = struct('subsample', sub, 'verbose', opt.verbose);
            [llx1,g1,H1] = mpm.nonlin.gradient(opt.parameters, in{v}, out, pre, subopt);
            
            llx = llx + llx1;
            g   = g   + g1; clear g1
            H   = H   + H1; clear H1
            
            if opt.verbose > 0, fprintf(' '); end
        end
        if opt.verbose > 0, fprintf('\n'); end

        % -----------------------------------------------------------------
        % Gradient: Absolute
        if any(opt.reg.mode(:,1) > 0)
            if opt.verbose > 0, fprintf('Gradient: absolute '); end
            for k=1:nbparameters
                if opt.reg.mode(k,1) == 2
                    fprintf('.');
                    y = single(out.(opt.parameters{k}).dat()) - opt.reg.mean(k);
                    g(:,:,:,k) = g(:,:,:,k) + vol * opt.reg.prec(k,1) * y;
                    H(:,:,:,k) = H(:,:,:,k) + vol * opt.reg.prec(k,1);
                    lly = lly - 0.5 * vol * opt.reg.prec(k,1) * sum(y(:).^2, 'double');
                    clear y
                end
            end
            if opt.verbose > 0, fprintf('\n'); end
        end

        % -----------------------------------------------------------------
        % Gradient: Membrane
        if any(opt.reg.mode(:,2) > 0)
            if opt.verbose > 0, fprintf('Gradient: membrane '); end
            w    = 0;
            wnew = 0;
            if any(opt.reg.mode(:,2) == 1), w = 1./single(out.W.dat()); end
            for k=1:nbparameters
                switch opt.reg.mode(k,2)
                    case 1
                        if opt.verbose > 0, fprintf('.'); end
                        Ly = single(out.(opt.parameters{k}).dat());
                        [Ly,Dy] = mpm.l1.vel2mom(Ly, opt.reg.prec(k,2), vs, w);
                        Dy = sum(sum(Dy.^2,5),4);
                        wnew = wnew + Dy;
                        g(:,:,:,k) = g(:,:,:,k) + vol * Ly;
                        clear Ly
                    case 2
                        if opt.verbose > 0, fprintf('.'); end
                        y  = single(out.(opt.parameters{k}).dat());
                        Ly = mpm.l2.vel2mom(y, opt.reg.prec(k,2), vs);
                        g(:,:,:,k) = g(:,:,:,k) + vol * Ly;
                        lly = lly - 0.5 * vol * sum(y(:).*Ly(:), 'double');
                        clear y Ly
                end
            end
            if opt.verbose > 0, fprintf('\n'); end
            if any(opt.reg.mode(:,2) == 1)
                wnew = sqrt(wnew + opt.reg.uncertainty);
                lly = lly - vol * sum(wnew(:), 'double');
            end
        end

        % -----------------------------------------------------------------
        % Update MTV weights
        if any(opt.reg.mode(:,2)==1) % && it > (opt.nbiter+s-1)/2
            if opt.verbose > 0, fprintf('Update: MTV weights\n'); end
            out.W.dat(:,:,:) = wnew; clear Wnew
        end

        % -----------------------------------------------------------------
        % Load diagonal of the Hessian
        % H(:,:,:,1:nbparameters) = bsxfun(@plus, H(:,:,:,1:nbparameters), sum(H(:,:,:,1:nbparameters)) * eps('single'));

        % -----------------------------------------------------------------
        % Gauss-Newton
        % - Compute step
        if all(opt.reg.mode(:,2) == 0)
        % No regularisation
            dy = mpm.l0.solve(H,g);
        elseif any(opt.reg.mode(:,2) == 1)
        % Some L1 regularisation
            % dy = opt.solver.fun(H, g, w, opt.reg.mode(:,2), vol * opt.reg.prec(:,2), vs, opt.solver);
            opt.solver.fmginit = false;
            opt.solver.nbiter  = 40;
            dy = mpm.l1.solve.cg(H, g, w, opt.reg.mode(:,2), vol * opt.reg.prec(:,2), vs, opt.solver);
            opt.solver.nbiter  = 10;
            dy = mpm.l1.solve.relax(H, g, w, opt.reg.mode(:,2), vol * opt.reg.prec(:,2), vs, opt.solver, dy);
        else
        % Some L2 but no L1 regularisation
            dy = mpm.l2.solve(H, g, opt.reg.mode(:,2), vol * opt.reg.prec(:,2), vs);
        end
        clear H g W
%         % - Update
%         if opt.verbose > 0, fprintf('Update: maps\n'); end
%         for k=1:nbparameters
%             prm = opt.parameters{k};
%             switch prm
%                 case 'A'
%                     mn = 0;
%                     mx = 2*mu(k);
%                 case 'R1'
%                     mn = 0;
%                     mx = 2;
%                 case 'R2s'
%                     mn = 0;
%                     mx = 120;
%                 case 'MT'
%                     mn = 0;
%                     mx = 0.05;
%                 case 'logA'
%                     mn = -Inf;
%                     mx = Inf;
%                 case 'logR1'
%                     mn = -Inf;
%                     mx = log(2);
%                 case 'logR2s'
%                     mn = -Inf;
%                     mx = log(120);
%                 case 'logMT'
%                     mn = -Inf;
%                     mx = log(0.05) - log(1-0.05);
%             end
%             out.(prm).dat(:,:,:) = single(out.(prm).dat(:,:,:)) - max(mn,min(mx,opt.armijo * dy(:,:,:,k)));
%         end
%         clear dy

        % -----------------------------------------------------------------
        % Line Search
        %   I have done a few simulations using typical values of R1/R2*
        %   in the grey and white matter, and a line search was necessary
        %   for convergence. I could not find a simple constant armijo 
        %   factor that made Gauss-Newton both fast and robust. A line
        %   search seems like the reasonable solutions (it requires
        %   additional computation but allows an optimum to be found in few
        %   iterations).
        armijo = opt.armijo;
        success = false;
        llx0   = llx;
        lly0   = lly;
        fprintf('init: %g\n', llx+lly);
        out0   = cell(1,nbparameters);
        for k=1:nbparameters
            prm = opt.parameters{k};
            out0{k} = single(out.(prm).dat());
            % Store in memory for now
        end
        for ls=1:12
            for k=1:nbparameters
                prm = opt.parameters{k};
                switch prm
                    case 'A'
                        mn = 0;
                        mx = 2*mu(k);
                    case 'R1'
                        mn = 0;
                        mx = 2;
                    case 'R2s'
                        mn = 0;
                        mx = 120;
                    case 'MT'
                        mn = 0;
                        mx = 0.05;
                    case 'logA'
                        mn = -Inf;
                        mx = Inf;
                    case 'logR1'
                        mn = -Inf;
                        mx = log(2);
                    case 'logR2s'
                        mn = -Inf;
                        mx = log(120);
                    case 'logMT'
                        mn = -Inf;
                        mx = log(0.05) - log(1-0.05);
                end
                % out.(prm).dat(:,:,:) = max(mn,min(mx,single(out0{k}) - armijo * dy(:,:,:,k)));
                out.(prm).dat(:,:,:) = single(out0{k}) - armijo * dy(:,:,:,k);
            end
            
            llx = 0;
            lly = 0;

            % -------------------------------------------------------------
            % Loop over volumes
            if opt.verbose > 0, fprintf('Log-likelihood: data '); end
            for v=1:numel(in)
                if opt.verbose > 0, fprintf('%d',v); end

                subopt = struct('subsample', sub, 'verbose', opt.verbose);
                llx1 = mpm.nonlin.gradient(opt.parameters, in{v}, out, pre, subopt);

                llx = llx + llx1;
                if opt.verbose > 0, fprintf(' '); end
            end
            if opt.verbose > 0, fprintf('\n'); end
            
            % -------------------------------------------------------------
            % Absolute
            if any(opt.reg.mode(:,1) > 0)
                if opt.verbose > 0, fprintf('Log-likelihood: absolute '); end
                for k=1:nbparameters
                    if opt.reg.mode(k,1) == 2
                        fprintf('.');
                        y = single(out.(opt.parameters{k}).dat()) - opt.reg.mean(k);
                        lly = lly - 0.5 * vol * opt.reg.prec(k,1) * sum(y(:).^2, 'double');
                        clear y
                    end
                end
                if opt.verbose > 0, fprintf('\n'); end
            end

            % -------------------------------------------------------------
            % Membrane
            if any(opt.reg.mode(:,2) > 0)
                if opt.verbose > 0, fprintf('Log-likelihood: membrane '); end
                w    = 0;
                wnew = 0;
                if any(opt.reg.mode(:,2) == 1), w = 1./single(out.W.dat()); end
                for k=1:nbparameters
                    switch opt.reg.mode(k,2)
                        case 1
                            opt.verbose > 0 && fprintf('.');
                            Ly = single(out.(opt.parameters{k}).dat());
                            [~,Dy] = mpm.l1.vel2mom(Ly, opt.reg.prec(k,2), vs, w);
                            Dy = sum(sum(Dy.^2,5),4);
                            wnew = wnew + Dy;
                            clear Ly
                        case 2
                            opt.verbose > 0 && fprintf('.');
                            y  = single(out.(opt.parameters{k}).dat());
                            Ly = mpm.l2.vel2mom(y, opt.reg.prec(k,2), vs);
                            lly = lly - 0.5 * vol * sum(y(:).*Ly(:), 'double');
                            clear y Ly
                    end
                end
                if opt.verbose > 0, fprintf('\n'); end
                if any(opt.reg.mode(:,2) == 1)
                    wnew = sqrt(wnew + opt.reg.uncertainty);
                    lly  = lly - vol * sum(wnew(:), 'double');
                end
            end
            
            
            % -------------------------------------------------------------
            % Check success
            fprintf('try: %g\n', llx+lly);
            if (llx+lly) > (llx0+lly0)
                success = true;
                break
            else
                armijo = armijo/2;
            end
        end
        if ~success
            llx = llx0;
            lly = lly0;
            for k=1:nbparameters
                prm = opt.parameters{k};
                out.(prm).dat(:,:,:) = out0{k};
            end
        end
        clear out0
        
        % -----------------------------------------------------------------
        % Log-likelihood
        ll  = [ll llx+lly];
        scl = [scl s];
        
        % -----------------------------------------------------------------
        % Gain
        if numel(ll) > it0
            gain = abs((ll(end) - ll(end-1)) / (ll(end-1) - min(ll(it0:end))));
        else
            gain = Inf;
        end

        % -----------------------------------------------------------------
        % Plot
        if opt.verbose > 0
            if opt.verbose > 1, mpm.nonlin.plot.progress(out,ll,scl,mu0); end
            fprintf('%s\n', repmat('-',[1 80]));
            fprintf('ll = %7.3g | llx = %7.3g | lly = %7.3g | gain = %7.3g\n', ll(end), llx, lly, gain);
            fprintf('%s\n', repmat('-',[1 80]));
        end
       
        % -----------------------------------------------------------------
        % Out?
        if gain < opt.tolerance
            break
        end

    end
        
    % ---------------------------------------------------------------------
    % Resize maps
    % ---------------------------------------------------------------------
    if s ~= 1
        out = mpm.resize_output(out, scales(s-1).dim);
        if opt.verbose > 1, mpm.nonlin.plot.progress(out,ll,scl,mu0); end
        % opt.armijo = opt.armijo/2;
    end
    
end

out = mpm.nonlin.exponentiate(out,opt.out.fname);

utils.threads.set(nthreads0);