function out = fit(in,pre,opt)
% Nonlinear MPM fit.
%
%   The MPM model derives unknown tissue (log(A), log(R1), log(R2*), 
%   logit(MT)) and aquisition (log(B1+), log(B1/-)) parameters from 
%   acquired volumes using their known influence on the signal equation. 
%   Currently, itonly  handles multi-echo spoiled gradient-echo 
%   acquisitions. 
%
% FORMAT out = mpm.nonlin.fit(in,opt)
%
% in  - Structure of input data generated by `mpm.io.input`
%
% opt - Structure of parameters with (optional) fields:
%   parameters   ['']      Parameters to estimate
%   nbscales     [5]       Number of scales (or zoom levels) 
%   nbiter       [3]       Number of iterations per scale
%   tolerance    [1E-4]    Gain threshold for early stopping (per scale)
%   out.folder   ['.']     Output folder 
%   out.fname    ['.nii']  Basis for output filenames 
%   out.mem      ['map']   Memory map or load output volumes (map|load)
%   reg.mode     [0 1]     Regularisation type (0=none|1=l1/tv|2=l2)
%   reg.prec.<c> [10 5E3]  Regularisation factor
%   reg.mean.<c> [NaN]     Prior mean
%   fov          [0]       Index of input FOV used for model space (0=bbox)
%   vs           [NaN]     Voxel size of model space
%   coreg        [true]    Initial co-registration
%   init         ['mean']  Init mode: 'mean'/'logfit'/'minilogfit'
%   subsample    [Inf]     Subsampling distance in mm
%   threads      [-1]      Number of threads used by SPM
%   solver.type      ['relax'] Solver used for L1 regularisation (relax|cg)
%   solver.nbiter    [10]      Number of iterations of the linear solver
%   solver.tolerance [0]       Solver gain threshold for early stopping
%   solver.verbose   [1]       Solver verbosity 
%
% Usually: `NaN` means 'informed default'
%          `Inf` means 'as precise as possible'
% reg.mode and reg.prec take two values: (1) absolute valuefPD,fT1,fMTs
%                                        (2) spatial gradients


% -------------------------------------------------------------------------
% Options
% -------------------------------------------------------------------------
if nargin < 2, pre = struct; end
if nargin < 3, opt = struct; end
opt = mpm.nonlin.opt(opt);

% -------------------------------------------------------------------------
% Multithread SPM
% -------------------------------------------------------------------------
nthreads0 = utils.threads.get();
utils.threads.set(opt.threads);

% -------------------------------------------------------------------------
% Index available contrasts (only keep FLASH volumes)
% -------------------------------------------------------------------------
issge       = cellfun(@(x) strcmpi(x.seq, 'SGE'), in);
in          = in(issge);
types       = cellfun(@(x) x.type, in, 'UniformOutput', false);
if isempty(opt.parameters)
    opt.parameters = {'logA' 'logR1' 'logR2s'};
    if any(strcmpi('MTw', types))
        opt.parameters = [opt.parameters {'logMT'}];
    end
end
nbparameters = numel(opt.parameters);

% -------------------------------------------------------------------------
% Default regularisation parameters
% -------------------------------------------------------------------------
% --- set default parameters
for prm=opt.parameters
    prm = prm{1};
    if~isfield(opt.reg.prec, prm)
        opt.reg.prec.(prm) = opt.reg.prec.default;
    end
    if~isfield(opt.reg.mean, prm)
        opt.reg.mean.(prm) = opt.reg.mean.default;
    end
    if~isfield(opt.reg.mode, prm)
        opt.reg.mode.(prm) = opt.reg.mode.default;
    end
end
% --- convert named parameters to vectors
reg0 = opt.reg;
opt.reg.mode = cell2mat(cellfun(@(x) reg0.mode.(x), opt.parameters(:), 'UniformOutput', false));
opt.reg.prec = cell2mat(cellfun(@(x) reg0.prec.(x), opt.parameters(:), 'UniformOutput', false));
opt.reg.mean = cellfun(@(x) reg0.mean.(x), opt.parameters(:));
% --- estimate mean parameter value
opt.verbose > 0 && fprintf('Guess mean parameter value\n');
mu = mpm.estatics.to_mpm_mini(mpm.estatics.loglin.fit.mini(in));
fields = fieldnames(mu);
for k=1:numel(fields)
   switch fields{k}
        case 'MT'
            mu.logMT.dat = log(mu.MT.dat) - log(1-mu.MT.dat);
        case 'A'
            mu.logA.dat = log(mu.A.dat);
        case 'R1'
            mu.logR1.dat = log(mu.R1.dat);
        case 'R2s'
            mu.logR2s.dat = log(mu.R2s.dat);
    end
    
end
mu = cellfun(@(x) mu.(x).dat, opt.parameters(:));
opt.reg.mean(isnan(opt.reg.mean)) = mu(isnan(opt.reg.mean));
for k=1:numel(opt.reg.mean)
    switch (opt.parameters{k})
        case 'logMT'
            expval = 1./(1+exp(-opt.reg.mean(k)));
        otherwise
            expval = exp(opt.reg.mean(k));
    end
    opt.verbose > 0 ...
    && fprintf('* Param %-6s | mean (log): %8.3g | mean (exp): %8.3g | prec (abs): %6.3g | prec (mem): %6.3g\n', ...
               opt.parameters{k}, opt.reg.mean(k), expval, opt.reg.prec(k,1), opt.reg.prec(k,2));
end

% -------------------------------------------------------------------------
% Co-registration
% -------------------------------------------------------------------------
opt.verbose > 0 && fprintf('Coregister volumes\n');
if opt.coreg
    [in,pre] = mpm.coregister(in,pre);
end

% -------------------------------------------------------------------------
% Prepare output
% -------------------------------------------------------------------------
opt.verbose > 0 && fprintf('Prepare output data structure\n');
% --- Field of view
dim = zeros(3,0);
mat = zeros(4, 4, 0);
for v=1:numel(in)
    dim(:,end+1)   = in{v}.dim(:)';
    mat(:,:,end+1) = in{v}.mat(:,:);
end
[dim,mat] = utils.fov(dim, mat, opt.vs, opt.fov);
% --- Multiscale settings
scales = mpm.compute_scales(opt.nbscales, dim, mat, opt.subsample);
% --- Prefix/Value
prefix = opt.parameters;
value  = zeros(1,nbparameters);
dim    = repmat([scales(end).dim(:); 1], [1 nbparameters]);
mat    = repmat(scales(end).mat, [1 1 nbparameters]);
if any(opt.reg.mode(:,2)==1)
    prefix = [prefix {'W'}];
    value  = [value 1];
    dim    = [dim [scales(end).dim(:); 1]];
    if ischar(opt.reg.uncertainty) && strcmpi(opt.reg.uncertainty, 'bayes')
        prefix = [prefix {'U'}];
        value  = [value 1E-3];
        dim    = [dim [scales(end).dim(:); nbparameters]];
    end
end
% --- Create
out = mpm.io.output(prefix, dim, mat, value, 'single', opt.out);

% -------------------------------------------------------------------------
% Initialise with loglinear fit
% -------------------------------------------------------------------------
switch lower(opt.init)
    case 'mean'
        for k=1:numel(opt.parameters)
            out.(opt.parameters{k}).dat(:) = opt.reg.mean(k);
        end
    case 'zero'
        % Nothing to do
    otherwise
        error('Initialisation mode ''%s'' not implemented.', init);
end
opt.verbose > 1 && mpm.nonlin.plot.progress(out,[]);

% -------------------------------------------------------------------------
% Nonlinear fit
% -------------------------------------------------------------------------
opt.verbose > 0 && fprintf('Full nonlinear fit\n');
ll  = [];
scl = [];
opt.reg.prec0 = opt.reg.prec;
for s=numel(scales):-1:1
    
    % ---------------------------------------------------------------------
    % Get scale specific parameters
    % ---------------------------------------------------------------------
    opt.verbose > 0 && fprintf('Scale %i\n', s);
    dim = scales(s).dim;
    % vs  = scales(s).vs;
    vs  = sqrt(sum(scales(s).mat(1:3,1:3).^2));
    sub = scales(s).sub;
    ff  = scales(s).ff;
    opt.reg.prec = ff * opt.reg.prec0 * prod(vs);
    
    % ---------------------------------------------------------------------
    % A bit of ad-hoc fudging for L2 regularisation
    % ---------------------------------------------------------------------
    opt.reg.prec(opt.reg.mode(:,2)==2,2) = opt.reg.prec(opt.reg.mode(:,2)==2,2) * power(10,s-1);
    
    it0 = numel(ll)+1;
    for it=1:(opt.nbiter+s)
    
        opt.verbose > 0 && fprintf('Iteration %i\n', it);

        % -----------------------------------------------------------------
        % Update maps
        % -----------------------------------------------------------------
        [ind,K] = utils.symIndices(nbparameters);  % Sparse indices for symmetric matrices
        g   = zeros([dim nbparameters], 'single'); % Gradient
        H   = zeros([dim K], 'single');            % Hessian (symmetric 4x4 matrix)
        llx = 0;                                   % Log-likelihood: data term
        lly = 0;                                   % Log-likelihood: prior term

        % -----------------------------------------------------------------
        % Loop over volumes
        opt.verbose > 0 && fprintf('Gradient: data ');
        for v=1:numel(in)
            opt.verbose > 0 && fprintf('%d',v);

            % - Compute gradient
            subopt = struct('subsample', sub, 'verbose', opt.verbose);
            [llx1,g1,H1] = mpm.nonlin.gradient(opt.parameters, in{v}, out, pre, subopt);
            
            llx = llx + llx1;
            g   = g   + g1; clear g1
            H   = H   + H1; clear H1
            
            opt.verbose > 0 && fprintf(' ');
        end
        opt.verbose > 0 && fprintf('\n');

        % -----------------------------------------------------------------
        % Gradient: Absolute
        if any(opt.reg.mode(:,1) > 0)
            opt.verbose > 0 && fprintf('Gradient: absolute ');
            for k=1:nbparameters
                if opt.reg.mode(k,1) == 2
                    fprintf('.');
                    y = single(out.(opt.parameters{k}).dat()) - opt.reg.mean(k);
                    g(:,:,:,k) = g(:,:,:,k) + opt.reg.prec(k,1) * y;
                    H(:,:,:,k) = H(:,:,:,k) + opt.reg.prec(k,1);
                    lly = lly - 0.5 * sum(y(:).^2, 'double');
                    clear y
                end
            end
            opt.verbose > 0 && fprintf('\n');
        end

        % -----------------------------------------------------------------
        % Gradient: Membrane
        if any(opt.reg.mode(:,2) > 0)
            opt.verbose > 0 && fprintf('Gradient: membrane ');
            w    = 0;
            wnew = 0;
            if any(opt.reg.mode(:,2) == 1), w = 1./single(out.W.dat()); end
            for k=1:nbparameters
                switch opt.reg.mode(k,2)
                    case 1
                        opt.verbose > 0 && fprintf('.');
                        Ly = single(out.(opt.parameters{k}).dat());
                        [Ly,Dy] = mpm.l1.vel2mom(Ly, opt.reg.prec(k,2), vs, w);
                        Dy = sum(sum(Dy.^2,5),4);
                        wnew = wnew + Dy;
                        g(:,:,:,k) = g(:,:,:,k) + Ly;
                        clear Ly
                    case 2
                        opt.verbose > 0 && fprintf('.');
                        y  = single(out.(opt.parameters{k}).dat());
                        Ly = mpm.l2.vel2mom(y, opt.reg.prec(k,2), vs);
                        g(:,:,:,k) = g(:,:,:,k) + Ly;
                        lly = lly - 0.5*sum(y(:).*Ly(:), 'double');
                        clear y Ly
                end
            end
            opt.verbose > 0 && fprintf('\n');
            if any(opt.reg.mode(:,2) == 1)
                if ischar(opt.reg.uncertainty) && strcmpi(opt.reg.uncertainty, 'bayes')
                    wnew = sqrt(wnew + sum(single(out.U.dat()), 4));
                else
                    wnew = sqrt(wnew + opt.reg.uncertainty);
                end
                lly = lly - sum(wnew(:), 'double');
            end
        end

        % -----------------------------------------------------------------
        % Update MTV weights
        if any(opt.reg.mode(:,2)==1)
            opt.verbose > 0 && fprintf('Update: MTV weights\n');
            out.W.dat(:,:,:) = wnew; clear Wnew
        end

        % -----------------------------------------------------------------
        % Log-likelihood
        ll  = [ll llx+lly];
        scl = [scl s];

        % -----------------------------------------------------------------
        % Load diagonal of the Hessian
        H(:,:,:,1:nbparameters) = bsxfun(@plus, H(:,:,:,1:nbparameters), sum(H(:,:,:,1:nbparameters)) * eps('single'));

        % -----------------------------------------------------------------
        % Gauss-Newton
        % - Compute step
        if all(opt.reg.mode(:,2) == 0)
        % No regularisation
            dy = mpm.l0.solve(H,g);
        elseif any(opt.reg.mode(:,2) == 1)
        % Some L1 regularisation
            dy = opt.solver.fun(H, g, w, opt.reg.mode(:,2), opt.reg.prec(:,2), vs, opt.solver);
            % Uncertainty about y
            if ischar(opt.reg.uncertainty) && strcmpi(opt.reg.uncertainty, 'bayes')
                out.U.dat(:,:,:,:) = mpm.l1.uncertainty(H, opt.reg.prec(:,2), vs, w);
            end
        else
        % Some L2 but no L1 regularisation
            dy = mpm.l2.solve(H, g, opt.reg.mode(:,2), opt.reg.prec(:,2), vs);
        end
        clear H g W
        % - Update
        opt.verbose > 0 && fprintf('Update: maps\n');
        for k=1:nbparameters
            prm = opt.parameters{k};
            switch prm
                case 'R2s'
                    out.(prm).dat(:,:,:) = max(0, out.(prm).dat(:,:,:) - dy(:,:,:,k));
                otherwise
                    out.(prm).dat(:,:,:) = out.(prm).dat(:,:,:) - dy(:,:,:,k);
            end
        end
        clear dy

        % -----------------------------------------------------------------
        % Gain
        if numel(ll) > it0
            gain = abs((ll(end) - ll(end-1)) / (ll(end-1) - min(ll(it0:end))));
        else
            gain = Inf;
        end

        % -----------------------------------------------------------------
        % Plot
        opt.verbose > 1 && mpm.nonlin.plot.progress(out,ll,scl);
        opt.verbose > 0 && fprintf('%s\n', repmat('-',[1 80]));
        opt.verbose > 0 && fprintf('ll = %7.3g | llx = %7.3g | lly = %7.3g | gain = %7.3g\n', ll(end), llx, lly, gain);
        opt.verbose > 0 && fprintf('%s\n', repmat('-',[1 80]));
       
        % -----------------------------------------------------------------
        % Out?
        if gain < opt.tolerance
            break
        end

    end
        
    % ---------------------------------------------------------------------
    % Resize maps
    % ---------------------------------------------------------------------
    if s ~= 1
        out = mpm.resize_output(out, scales(s-1).dim);
        opt.verbose > 1 && mpm.nonlin.plot.progress(out,ll,scl);
    end
    
end

out = mpm.nonlin.exponentiate(out,opt.out.fname);

utils.threads.set(nthreads0);